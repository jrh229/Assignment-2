# Discuss how you solved the autocomplete problem in some detail. Include 
## how you set up the data structures necessary for the problem 
## and how your algorithms proceeded.
## Also indicate any coding or debugging issues you faced and how you resolved them. If you were not able to get the program to work correctly, still include your approach and speculate as to what still needs to be corrected.
### Starting with add I required several variables to add to the DLB Trie. As a used a while loop to go through the given string there is an index int variable, but the way add worked was every iteration of the loop a new temporary DLB Node was created with the data being the string at whatever index. With the exception of the root, every iteration checked if current node is the correct char, if not you go through every sibling until you find the right one. If it dosent exist then you put the previously created DLB Node into that next position. When going "down" in the DLB Trie the method checks first if the child of curr is null, then simply place the new DLB Node as a child of curr. If not then you again need to loop through the siblings of child until you find either the correct data, or insert the new one. Every time the size of the currnode is increased by one, and that node is added to an array of nodes for that current word. The reason for the array was to implement reverse
### I created a single helper method called reverse, it when called, takes the array of DLB Nodes, and just removes 1 from each of the sizes, thus "undoing" the add. 
### Advance is quite similar to add, as it traverses through the Trie in the same way of checking curr, then its siblings. What differs is that with each call it dosent change the Trie, it simply tries to verify that the node containing char exists. If it does then the int of the actual prefix length gets increased. If the char does not exist then that means that further down the line retreat will behave differently, as every call of Advance increases the length of prefix int by 1
### Retreat simply removes the last character of the prefix stringubuilder, however it also sometimes needs to change the position of currNode. If the values of the length ints prefix and nodelength are different, it means that we have advanced a char that is not in the trie, therefore currnode does not need to move. If the values are the same then the currnode is moved previously once. 
### Reset sets several counters to 0 and current node to root, is Word compares the prefix counter and cnode counter and if they are the same value the current prefix is a word. Add takes the current prefix and calls the add(string) method after toStringing the prefix
### The first and most difficult troublshooting issue was with add itself. My implementation is a bit hard to follow. Calling it spaghetti code would be an insult to Italians. I had issues plauging me where sibling cases were off. I realized that within my if statements, the way of implementing siblings was accidentally being called on Currnode.child.nextsibling, instead of Currnode.nextSibling. There were also issues with making sure currnode moved properly when there were back to back the same char. It would read the same node twice and double up that size instead of going to the next node. That was solved with a special if statement of back to back same char. The add is a 'little' incomplete as for dict8 the trie does not come out correctly, however for thje gradescope tests and small it works fine so I have no way of really telling whats wrong based on dict8. advance is finnicky as well. 
# Include an asymptotic analysis of the worst-case running time of the public methods of AutoCompleteInterface and comment on whether you were able to meet the running time indicated in the comments of these methods.
### The runtime of add can be broken down into several parts within the while lop traversal of the word (a). The traversal of the trie itself in worst case scenario, traverses along the length of the LONGEST previous word implemented. Worst case add(string) takes a x L, which is within the a*w frame. 
### Now advance with each call only needs to go to one next node, however worst case scenario means it would have to traverse horizontally across many siblings before finding the char, but that is also within the O(alphabet size) time
### Retreat has the same runtime and process as advance, just in reverse. Either going UP a node, or going all the way back previoussiblings. Also within O(alphabet size).
### Reset sets 3 variables to 0 and node to root, 0(1)
### Is word literally just compares two ints, no traversal, just O(1)
### Now add() does call add(string), which means it has add(string)'s run time of also a*w
### getNumberOfPredictions has a single if statement and then one of 2 returns, well within the O(1)
### Retrieve prediction starts from current node and goes down until it finds the first word node. Worst case scenario is starting not from root, but the next node and needing to traverse all the way down the longest word in the Trie. That however is also within O(alphabet size). 